const LEGACY_THEME_MESSAGING = [
  {
    "name": "primary",
    "key": "e5443fa4baf8e1c1127fbdfc733306f9e4329d03",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedPrimary",
    "key": "e4b56a0bad12f4fefdba6a9d5fc75bddb0ae6d10",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onPrimary",
    "key": "f823cf0ba70e5fbe77e20688865689da70f4e246",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "action",
    "key": "7c792b38fe5ff6c0617ad969e600c0f0c2131f31",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedAction",
    "key": "ba2fba71a424972f1affd7f959a1859fdf9a55e8",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onAction",
    "key": "ded082a1c3722b94456e1745698dcbd1ec4bde68",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "message",
    "key": "fc0f2c43b86a35dcd01f3166a102b9734744f5da",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedMessage",
    "key": "c07e83d4c7b7d2d549895455d5e61a203f04b280",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onMessage",
    "key": "1d8e481ed4893c0adea965ec52089f01c861adf8",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "inboundMessage",
    "key": "126086ca84dfd17398c7cbd853c8dd467e705b31",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "systemMessage",
    "key": "6686cfd9341e8200fb23c198f7454e8acacf05c8",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "borderSystemMessage",
    "key": "aa9586c30be873f7cfbbb46a2143ab320c62be47",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "background",
    "key": "e94370ef7b3a645e93bd29da94dc67ad6b6ec52e",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onBackground",
    "key": "3af20e1008a1869ee994b91d94a0abb68d4c3fa2",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "danger",
    "key": "6fbdd12e50f2f5c3c99d8cf8b03ddfaff79dcc5d",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onDanger",
    "key": "b9a1320f9bdbb06c9bca2316883dc0681ec885a1",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "success",
    "key": "04a41d4e26ca223cd6675da87192b67c3617da16",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "notify",
    "key": "1f060b8138d4d88e897b3584ce63fb101d8a6163",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "disabled",
    "key": "728181bfeb7e563c725a5ec3466206898dbef5e3",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "icon",
    "key": "272a513440d5a8926e1e09ead7914bd6818d4aaa",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "note",
    "key": "d8e967f944e4661d0a126d6d38a75add4817e948",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onNote",
    "key": "03c0d98a50b7203ec9689bead189fd4f4739a7a8",
    "theme": "Messaging (light)",
    "type": "PAINT"
  }
]
const LEGACY_THEME_ZENDESK = [
  {
    "name": "primary",
    "key": "ef31f973947bf366fc155f8f1d1b5c9615f6fcae",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedPrimary",
    "key": "5d5f37692871fbbbf038e7024f65646f85e0ab98",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onPrimary",
    "key": "55e6361fc7e71c46adca786c65de717d0ce0b80c",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "action",
    "key": "0438ba05cfd60614d4206cf5c9a07db493e338d0",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedAction",
    "key": "299b8b046dc79e7f19fd311d685bf758ace536ac",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onAction",
    "key": "7d4b06d81bdb29e8dd7710984490b454db30c14a",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "message",
    "key": "80a524956e565142133376c5b666f49bd05cb883",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedMessage",
    "key": "13fa30bfb7e77798e05532aa5d95e689ce8fe300",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onMessage",
    "key": "c90964aa8b922a75dccf63d647084a04f3408c31",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "inboundMessage",
    "key": "563012a9ef6ac8a456a33af731991e9976668d73",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "systemMessage",
    "key": "0fd31dfc163a3f11df082375939821120ee2c0a9",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "borderSystemMessage",
    "key": "647073225e8ff394b0251adf0d6fa602d831d433",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "background",
    "key": "cf7817bd540ba537da50e405e4c7a50ebb5319ea",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onBackground",
    "key": "190e1e048d8f2616d6f057ddccb5509667735077",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "danger",
    "key": "09fc4a7ccfc0b2a63587acada847105171ab02f5",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onDanger",
    "key": "9ad0bac10994e1a43c7cd1ede27898405fc5938b",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "success",
    "key": "a4501a0afde40681948565aa7f1d9cd6ee216de2",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "notify",
    "key": "e79a0e3fd0aa817ce37e350f7cc5c1f60ea07f20",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "disabled",
    "key": "3541b5f8a20efa343d690751c9ae1b70c62429d4",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "icon",
    "key": "6660bd31c0bfb42bd8b044a7dd233293973336fd",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "note",
    "key": "4f9162ff25d0b16dfea4121dd1b1a3ecd006d1c6",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onNote",
    "key": "e2510f9b0c5b036e4ef04ff7f0dac1d0f6e7fc3a",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  }
]
const THEME_MESSAGING = [
  {
    "name": "primary",
    "key": "5beedf916e5ba9df061a6190364a7b6cd3875925",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedPrimary",
    "key": "29bc03eefd846a37181062777d981bb4debdf540",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "message",
    "key": "6fe43e974e632be9b11fac89e2d3b0955643094e",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedMessage",
    "key": "e79e7770c5db15e60089cee196d72e7f4d118484",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "action",
    "key": "cb436db74a1b5f4880490f069fd454b7b65d6bad",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedAction",
    "key": "8c92e22a1b0272e773320e2e5b8f929ff2ad0908",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onPrimary",
    "key": "a7d3cd5b69c3f32cbbd2437a3e5e2228a00d72da",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onMessage",
    "key": "339dd4f6524f41df097082e240e67e9c51674591",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onAction",
    "key": "b2e38b5ac5e722acdde3bc988eadd6163414a4b2",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "actionBackground",
    "key": "501dbc18d692d6aa8465a740d1025c0ce9facfd0",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onActionBackground",
    "key": "815129ecfbea622f588bdb0766321245bd1f606c",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "note",
    "key": "b3327a112d4b57290044563abf268ad2ae115fe0",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onNote",
    "key": "316677970c51230ff5ca0f5a86c1e039924f0865",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "inboundMessage",
    "key": "9f75dead04abba7134689230da777924a2130be8",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "systemMessage",
    "key": "0c0e5c0676301a8ea9a5dc6fb1b70fdd5028efee",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "borderSystemMessage",
    "key": "25e89c6025e0ecdee18d161a543149b6a9a44d0a",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "background",
    "key": "beb55fec14b02dfcdc39b5f6d262a7b23e17dcc1",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onBackground",
    "key": "c2280481b2c5146e27b8bc84486bb586e93204e9",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "elevated",
    "key": "7daad5f47047f3fc8cdd1791d05037e1fa2b14c7",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "danger",
    "key": "6489aa8b199f5befad6d03f2381ed36596dcc034",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onDanger",
    "key": "f9d919b51c348d1c2b4952089cda6d563f04469c",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "success",
    "key": "568b4b64344a1ec285245075249dacf593b6f509",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "notify",
    "key": "6fb8cd96453762d9a92a43988db571e3dddb141b",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "disabled",
    "key": "9d48d47863dab62909cc2f50b0f7d7fe35c80ab8",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "icon",
    "key": "7f17593681d6bc61eaae70d7b2c11a2d4bdcb3ca",
    "theme": "Messaging (light)",
    "type": "PAINT"
  }
]
const THEME_ZENDESK = [
  {
    "name": "primary",
    "key": "bf87155d30dbbd8b2938ea75e4e38b232bd8b411",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedPrimary",
    "key": "3172cf251eb5efd3aab7e9b74924245348e21767",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "message",
    "key": "fdd6facaaaccf390dc2f3837f79ee974bf292529",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedMessage",
    "key": "e9db3ca314777aadfc0553374dfce4315ef85a0d",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "action",
    "key": "16f27893231b978c2783be8ea609293843687786",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedAction",
    "key": "b42d74fa99f44874e88d7bca54ee644c6e7e8742",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onPrimary",
    "key": "b14f0cdb1b8bada152555bf750e87a4b08111686",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onMessage",
    "key": "b6ab708f33e12dc904c5d4d998124e68256336a4",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onAction",
    "key": "9404368ab712076eb39872b39ed6542959670122",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "actionBackground",
    "key": "ca9be8606f4619972d2e463d82752781c56b6542",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onActionBackground",
    "key": "5598eac77ed1b14e75d5283327d4bdbe96e5ee09",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "note",
    "key": "fcd1f793ecc9442bfe884de133adf17e4d046975",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onNote",
    "key": "c62cfd2f389cd101d1e9c647c1ee3e9da8d9d4e5",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "inboundMessage",
    "key": "bd211e22f148db1e16db5af5ac3d306b76db6e38",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "systemMessage",
    "key": "22bb0515a63bb597fb581c87e684ed5e47f62a59",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "borderSystemMessage",
    "key": "ea6d2dd3b979568e3dadde2f55ab4b4b99633141",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "background",
    "key": "fd73eb89b9d8ca51c3e721b54a8b77b3871e3189",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onBackground",
    "key": "d194886b6bef18911df194192dbbb254416354cc",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "elevated",
    "key": "a0f36b2eaad81aaee4dc30cb4217d7621dfa19fc",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "danger",
    "key": "161ae0cc948555b2c33a2731b9c62811817a7729",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onDanger",
    "key": "83c4d892534676ea83a71ab946f830c8ccde82f6",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "success",
    "key": "65cbf8c0e2588e30a7937105d935c3be66d6d906",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "notify",
    "key": "002e4f8c1fc8239b6e16fcf01a110178824234d5",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "disabled",
    "key": "0b582e7883a5d86e41e7e6dfb8f21750210e0638",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "icon",
    "key": "2fdf32794a19801b3bff833a7e0b9a8058caf9cf",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  }
]

var messageCount: number = 0
var log: FrameNode

// This plugin will open a window to prompt the user to enter a message, and
// it will then create a message symbol with that text on screen.

// This file holds the main code for the plugins. It has access to the *document*.
// You can access browser APIs in the <script> tag inside "ui.html" which has a
// full browser environment (see documentation).

// This shows the HTML page in "ui.html".
figma.showUI(__html__)
figma.ui.resize(400, 100)

//Secret bootstrap point setter -- commment out when not in use.
// let launcher = figma.currentPage.selection.find(node => (node.type == "COMPONENT" || node.type == "INSTANCE") && node.parent.name == "Launcher")
// if (launcher){
//   launcher.setRelaunchData({start: ""})
//   figma.closePlugin()
// }

// Calls to "parent.postMessage" from within the HTML page will trigger this
// callback. The callback will be passed the "pluginMessage" property of the
// posted message.
figma.ui.onmessage = async msg => {
  //Look for a "Widget" or a "Messenger" in the current selection
  let widget = figma.currentPage.selection.find(node => node.type === "FRAME" && node.name == "Widget") as FrameNode
  let messenger = figma.currentPage.selection.find(node => node.type === "FRAME" && node.name == "Messenger") as FrameNode
  // Then look for a child 'Log' frame...
  if (widget) {
    log = widget.findOne(node => node.type === "FRAME" && node.name == "Log") as FrameNode;
  } else if (messenger) {
    log = messenger.findOne(node => node.type === "FRAME" && node.name == "Log") as FrameNode;
  }
  // One way of distinguishing between different types of messages sent from
  // your HTML page is to use an object with a "type" property like this...
  switch (msg.type) {
    case 'setup':
      let setupNotification = figma.notify("Setting up widget...", {timeout: Infinity });
      await setUp()
      setupNotification.cancel()
      break
    case 'create-message':
      await sendMessage(msg.messageType, msg.message, msg.direction, msg.isBot)
      break
  }
};

//~~Function to set up a new conversation~~//
async function setUp() {
  if (!log) {
    //Set up styles
    let backgroundStyle = await figma.importStyleByKeyAsync("beb55fec14b02dfcdc39b5f6d262a7b23e17dcc1").catch(() => {
      figma.notify("Zcripter requires the 'Theme: Messaging (Default)' library.");
      figma.closePlugin();
    }) as BaseStyle;
    let backgroundEffect = await figma.importStyleByKeyAsync("20b0405ad7024a20ad878b90b3b75bd5bb26443a").catch(() => {
      figma.notify("Zcripter requires the 'Garden' library.");
      figma.closePlugin();
    }) as BaseStyle;

    //Find last widget...
    let otherWidgets = figma.currentPage.findAll(node => node.name == "Widget")

    //Make the container
    let widget = figma.createFrame();
    widget.setRelaunchData({ open: "" });
    widget.name = "Widget";
    // If there are other containers, offset it to the right of the last one.
    if (otherWidgets.length > 0) {
      widget.x = otherWidgets[otherWidgets.length-1].x + 480
      widget.y = otherWidgets[otherWidgets.length-1].y
    } else {
      widget.x = figma.viewport.center.x - 190
      widget.y = figma.viewport.center.y - 390
    }
    widget.resize(380, 780);
    widget.clipsContent = false;
    widget.fills = [];
    widget.layoutMode = "VERTICAL";
    widget.primaryAxisSizingMode = "AUTO";
    widget.counterAxisSizingMode = "AUTO";
    widget.counterAxisAlignItems = "MAX";
    widget.itemSpacing = 8;

    //Make the messenger
    let messenger = figma.createFrame();
    messenger.setRelaunchData({ open: "" });
    messenger.name = "Messenger";
    messenger.resize(380, 700);
    messenger.layoutMode = "VERTICAL";
    messenger.primaryAxisSizingMode = "FIXED";
    messenger.fillStyleId = backgroundStyle.id;
    messenger.effectStyleId = backgroundEffect.id;
    widget.appendChild(messenger);

    //Make the launcher
    let launcher: InstanceNode
    if(figma.command == "start"){
      launcher = figma.currentPage.selection.find(node => node.type == "INSTANCE" && node.name == "Launcher") as InstanceNode
      widget.x = launcher.x - 308
      widget.y = launcher.y - 708
      launcher.swapComponent(await figma.importComponentByKeyAsync("c5f2c7b8417b86629a8e52aa37ebe2c065a2c6de"));
      launcher.parent.appendChild(widget)
    } else {
      launcher = (await figma.importComponentByKeyAsync("c5f2c7b8417b86629a8e52aa37ebe2c065a2c6de")).createInstance()
    }
    launcher.setRelaunchData({})
    widget.appendChild(launcher);

    //Make the header
    let header = (await figma.importComponentByKeyAsync("da85778fa3e3f54485fcedfe1bf2476f851f2f41")).createInstance();
    messenger.appendChild(header);
    let title = header.findChild(node => node.name == "Title") as TextNode;
    await figma.loadFontAsync(title.fontName as FontName).then();
    title.characters = "Zendesk";
    header.layoutAlign = "STRETCH";

    //Make a log frame
    log = figma.createFrame();
    log.name = "Log";
    log.resize(380, 1);
    log.layoutMode = "VERTICAL";
    log.layoutGrow = 1;
    log.layoutAlign = "STRETCH";
    log.overflowDirection = "VERTICAL";
    log.fills = [];
    messenger.appendChild(log);

    //Make the composer
    let composer = (await figma.importComponentByKeyAsync("0cdeaec0c5baf216b6c74d1a939a9c94e025f1df")).createInstance();
    composer.layoutAlign = "STRETCH";
    messenger.appendChild(composer);
    //Ensure the Messenger theme is applied
    applyColor(widget)

    const nodes: SceneNode[] = [];
    nodes.push(widget);
    figma.currentPage.selection = nodes;
    figma.viewport.scrollAndZoomIntoView(nodes);
  }
  //Now that we are sure there is a conversation, check if there is any messages.
  var firstMessage = log.findChild(node => node.name == "0" && node.type === "INSTANCE") as InstanceNode;
  //If there is no first message...
  if (!firstMessage) {
    //Create a first timestamp messsage...
    await figma.importComponentByKeyAsync("663b06bfe927cf5574dc82c60e084da2ee5e99d9").then(timestampComponent => {
      firstMessage = timestampComponent.createInstance();
    });
    firstMessage.name = "0";
    messageCount = 0;
    firstMessage.layoutAlign = "STRETCH";
    let timestamp = firstMessage.findChild(node => node.type == "TEXT" && node.name.includes("Timestamp")) as TextNode
    let d = new Date(Date.now())
    const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    let locDate = months[d.getMonth()] + " " + d.getDate() + ", " + (d.getHours() > 12 ? d.getHours()%12 : d.getHours()) + ":" + ("0" + d.getMinutes()).slice(-2) + " " + (d.getHours()/12 < 1 ? "AM" : "PM")
    setText(timestamp, locDate)
    applyColor(firstMessage)
    log.insertChild(0, firstMessage);
  }
}

//~~Function to send a message~~//
async function sendMessage(messageType: string, messageText: string, directionIsOutbound: boolean, isBot: boolean) {
  //Find the last message in the conversation frame...
  let lastMessageGroup = log.children[log.children.length-1] as InstanceNode
  //...and set the messageCount to the numbered name of this message
  messageCount = parseInt(lastMessageGroup.name)
  let positionInGroup: number

  //If last message type is quick reply...
  if (lastMessageGroup.mainComponent.parent.name == "Quick replies") {
    //...and next message is a quick reply, add to group.
    if (messageType == "quick reply") {
      let replyCount = parseInt(lastMessageGroup.getPluginData("replies"))
      if (replyCount > 15) {
        figma.notify("More than 16 not supported")
      }
      lastMessageGroup.setPluginData("replies", (++replyCount).toString())
      let rows = Math.ceil(replyCount / 4)
      lastMessageGroup.setProperties({Rows: rows.toString()})
      let columns = replyCount % 4 ? replyCount % 4 : 4
      let lastRow = lastMessageGroup.findChild(node => node.name == "Row " + rows) as InstanceNode
      lastRow.setProperties({Replies: columns.toString()})
      applyColor(lastMessageGroup)
      return
    } else {
      //Else clean up the quick reply.
      lastMessageGroup.remove()
      lastMessageGroup = log.children[log.children.length-1] as InstanceNode
      messageCount--
    }
  }

  //If message type is quick reply just add it, as it cannot be grouped.
  if (messageType == "quick reply") {
    let quickRepliesComponent: ComponentNode
    await figma.importComponentSetByKeyAsync("b929d6648712cdcae0f3ce4a4195d2ea70badca2").then( quickRepliesComponentSet => {
      quickRepliesComponent = quickRepliesComponentSet.findChild(component => true) as ComponentNode
    })
    var quickRepliesInstance = quickRepliesComponent?.createInstance()
    quickRepliesInstance.layoutAlign = "STRETCH"
    quickRepliesInstance.name = (++messageCount).toString();
    quickRepliesInstance.setPluginData("replies", "1")
    applyColor(quickRepliesInstance)

    //Insert the new message.
    log.insertChild(messageCount, quickRepliesInstance);

    //Check that the log has not become filled
    if (quickRepliesInstance.y + quickRepliesInstance.height > log.height) {
      log.primaryAxisAlignItems = "MAX"
    }
    return
  }

  //If participant hasn't changed since last message...
  if ((directionIsOutbound && lastMessageGroup.mainComponent.name.startsWith("Direction=Outbound")) ||
  (!directionIsOutbound && lastMessageGroup.mainComponent.name.startsWith("Direction=Inbound"))) {
    positionInGroup = parseInt(lastMessageGroup.variantProperties.Messages) + 1
    //Add to the existing message group
    var nextMessageGroup = lastMessageGroup
    if (positionInGroup < 4) {
      //TODO Investigate making this scalable beyond 3 messages by appending an new message, vs swapping component.
      nextMessageGroup.setProperties({
        Direction: nextMessageGroup.variantProperties.Direction,
        Messages: (positionInGroup).toString()
      })
    } else {
      figma.notify("Conversation Kit currently only supports 3 consecutive messages.")
      return
    }
  } else {
    //Start a new message group...
    positionInGroup = 1
    let messageGroupComponent: ComponentNode
    await figma.importComponentSetByKeyAsync("98e8f2af5cef20537dfbfb1dc294f6fc1f60d466").then( messageGroupComponentSet => {
      messageGroupComponent = directionIsOutbound ? messageGroupComponentSet.findChild(component => component.name === "Direction=Outbound, Messages=1") as ComponentNode : messageGroupComponentSet.findChild(component => component.name === "Direction=Inbound, Messages=1") as ComponentNode
    })
    var nextMessageGroup = messageGroupComponent?.createInstance()
    nextMessageGroup.layoutAlign = "STRETCH"
    nextMessageGroup.name = (++messageCount).toString();

    //Turn off receipts on previous message, if there is one
    let receipt = lastMessageGroup.findOne(node => node.name == "Receipt")
    if (receipt) receipt.visible = false

    //Insert the new message.
    log.insertChild(messageCount, nextMessageGroup);
  }

  //If outbound...
  if (!directionIsOutbound) {
    //...and is bot...
    if (isBot) {
      //Set the author label
      let label = nextMessageGroup.findOne(node => node.type === "TEXT" && node.name == "Label") as TextNode;
      await figma.loadFontAsync(label.fontName as FontName).then(() => {
        label.characters = "Zendesk Bot";
      });

      //Set the avatar
      let avatar = nextMessageGroup.findOne(node => node.name == "Avatar") as InstanceNode;
      avatar.setProperties({
        Size: "Small",
        Shape: "Square",
        Type: "Image",
        State: "Default"
      })
      let avatarImage = avatar.findOne(node => node.name == "Images") as InstanceNode
      avatarImage.setProperties({ Participant: "Bot" })
    } else {
      //Set the author label, if it is an inbound message
      let label = nextMessageGroup.findOne(node => node.type === "TEXT" && node.name == "Label") as TextNode;
      await figma.loadFontAsync(label.fontName as FontName).then(() => {
        label.characters = "Christina";
      });

      //Set the avatar
      let avatar = nextMessageGroup.findOne(node => node.name == "Avatar") as InstanceNode;
      avatar.setProperties({
        Size: "Small",
        Shape: "Square",
        Type: "Image",
        State: "Default"
      })
      let avatarImage = avatar.findOne(node => node.name == "Images") as InstanceNode
      avatarImage.setProperties({ Participant: "Agent (Christina)" })
    }
  }

  let message = nextMessageGroup.findOne(node => node.name == "Message " + (positionInGroup)) as InstanceNode
  switch (messageType) {
    case "text":
      //Set the message text
      let text = message.findOne(node => node.type === "TEXT" && node.name == "Text") as TextNode;
      await figma.loadFontAsync(text.fontName as FontName).then(() => {
        text.characters = messageText;
      });
      //Check that the message should not be multi-line
      if( nextMessageGroup.mainComponent.name.startsWith("Direction=Outbound") ? text.width > log.width-92-28 : text.width > log.width-64-60 ){
        message.setProperties({
          Multiline: "True"
        })
      }
      break
    case "image":
      message.setProperties({
        Type: "Image",
        Multiline: "True",
        State: "Sent"
      })
      break
    case "file":
      message.setProperties({
        Type: "File",
        Multiline: "True",
        State: "Sent"
      })
      break
    case "quick reply":
      break
  }

  //Check that the log has not become filled
  if (nextMessageGroup.y + nextMessageGroup.height > log.height) {
    log.primaryAxisAlignItems = "MAX"
  }

  applyColor(nextMessageGroup)
}

//~~~UTILITIES~~~//

//~~Function to safely change text on TextNodes.~~//
async function setText(node: TextNode, text: string) {
  await figma.loadFontAsync(node.fontName as FontName)
  node.characters = text
}

//~~Function to clone fills, etc. so they can be set.~~//
function clone(val) {
  const type = typeof val
  if (val === null) {
    return null
  } else if (type === 'undefined' || type === 'number' ||
             type === 'string' || type === 'boolean') {
    return val
  } else if (type === 'object') {
    if (val instanceof Array) {
      return val.map(x => clone(x))
    } else if (val instanceof Uint8Array) {
      return new Uint8Array(val)
    } else {
      let o = {}
      for (const key in val) {
        o[key] = clone(val[key])
      }
      return o
    }
  }
  throw 'unknown'
}

//~~Function to loop through every node and apply a matching color style if found
//  it will ignore any layer without a fill, background, or stroke style applied
function applyColor(node) {

  //iterate through children if the node has them
  if (node.children) {
      node.children.forEach(child => {
          applyColor(child);
      })
  }

  //handle background fills
  if (node.type === 'COMPONENT'||'INSTANCE'||'FRAME'||'GROUP') {
      if (node.backgroundStyleId) {
          (async function() {
              let style = figma.getStyleById(node.backgroundStyleId) as PaintStyle;
              if (style.key) {
                  let newStyleKey = findMatchInSelectedTheme(style.key);
                  if (newStyleKey) {
                      let newStyle = await figma.importStyleByKeyAsync(newStyleKey) as PaintStyle;
                      if (newStyle) {
                          node.backgroundStyleId = newStyle.id;
                      }
                  }
              }
          })()
      }
  }

  //handle fills + strokes
  if (node.type === 'RECTANGLE'||'POLYGON'||'ELLIPSE'||'STAR'||'TEXT'||'VECTOR'||'BOOLEAN_OPERATION'||'LINE') {
      //fills
      if (node.fillStyleId) {
          (async function() {
              let style = figma.getStyleById(node.fillStyleId) as PaintStyle;
              if (style.key) {
                  let newStyleKey = findMatchInSelectedTheme(style.key);
                  if (newStyleKey) {
                      let newStyle = await figma.importStyleByKeyAsync(newStyleKey) as PaintStyle;
                      if (newStyle) {
                          node.fillStyleId = newStyle.id;
                      }
                  }
              }
          })()
      }
      //strokes
      if (node.strokeStyleId) {
          (async function() {
              let style = figma.getStyleById(node.strokeStyleId) as PaintStyle;
              if (style.key) {
                  let newStyleKey = findMatchInSelectedTheme(style.key);
                  if (newStyleKey) {
                      let newStyle = await figma.importStyleByKeyAsync(newStyleKey) as PaintStyle;
                      if (newStyle) {
                          node.strokeStyleId = newStyle.id;
                      }
                  }
              }
          })()
      }
  }
}
//find matching styles based
function findMatchInSelectedTheme(styleKey) {
  // this gets item in the array which matches the current style applied
  let currentStyle = LEGACY_THEME_ZENDESK.find(style => style.key === styleKey) || THEME_ZENDESK.find(style => style.key === styleKey);
  
  // if we find a matching style execute this
  if (currentStyle) {

      //this gets the name of the current style
      //we need the name of the current style so we can search the jsonbin array
      //for matches with the selected theme
      let name = currentStyle.name;
      let matchedStyle = THEME_MESSAGING.find(style => style.name === name) || LEGACY_THEME_MESSAGING.find(style => style.name === name);
     
      if (matchedStyle) {
          //if we find a match in the selected theme, we will return the style key
          // so that we can import the style into the doc
          return matchedStyle.key;
      }
  }
}