const THEME_MESSAGING = [
  {
    "name": "primary",
    "key": "e5443fa4baf8e1c1127fbdfc733306f9e4329d03",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedPrimary",
    "key": "e4b56a0bad12f4fefdba6a9d5fc75bddb0ae6d10",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onPrimary",
    "key": "f823cf0ba70e5fbe77e20688865689da70f4e246",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "action",
    "key": "7c792b38fe5ff6c0617ad969e600c0f0c2131f31",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedAction",
    "key": "ba2fba71a424972f1affd7f959a1859fdf9a55e8",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onAction",
    "key": "ded082a1c3722b94456e1745698dcbd1ec4bde68",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "message",
    "key": "fc0f2c43b86a35dcd01f3166a102b9734744f5da",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedMessage",
    "key": "c07e83d4c7b7d2d549895455d5e61a203f04b280",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onMessage",
    "key": "1d8e481ed4893c0adea965ec52089f01c861adf8",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "inboundMessage",
    "key": "126086ca84dfd17398c7cbd853c8dd467e705b31",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "systemMessage",
    "key": "6686cfd9341e8200fb23c198f7454e8acacf05c8",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "borderSystemMessage",
    "key": "aa9586c30be873f7cfbbb46a2143ab320c62be47",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "background",
    "key": "e94370ef7b3a645e93bd29da94dc67ad6b6ec52e",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onBackground",
    "key": "3af20e1008a1869ee994b91d94a0abb68d4c3fa2",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "danger",
    "key": "6fbdd12e50f2f5c3c99d8cf8b03ddfaff79dcc5d",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onDanger",
    "key": "b9a1320f9bdbb06c9bca2316883dc0681ec885a1",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "success",
    "key": "04a41d4e26ca223cd6675da87192b67c3617da16",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "notify",
    "key": "1f060b8138d4d88e897b3584ce63fb101d8a6163",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "disabled",
    "key": "728181bfeb7e563c725a5ec3466206898dbef5e3",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "icon",
    "key": "272a513440d5a8926e1e09ead7914bd6818d4aaa",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "note",
    "key": "d8e967f944e4661d0a126d6d38a75add4817e948",
    "theme": "Messaging (light)",
    "type": "PAINT"
  },
  {
    "name": "onNote",
    "key": "03c0d98a50b7203ec9689bead189fd4f4739a7a8",
    "theme": "Messaging (light)",
    "type": "PAINT"
  }
]
const THEME_ZENDESK = [
  
  {
    "name": "primary",
    "key": "ef31f973947bf366fc155f8f1d1b5c9615f6fcae",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedPrimary",
    "key": "5d5f37692871fbbbf038e7024f65646f85e0ab98",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onPrimary",
    "key": "55e6361fc7e71c46adca786c65de717d0ce0b80c",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "action",
    "key": "0438ba05cfd60614d4206cf5c9a07db493e338d0",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedAction",
    "key": "299b8b046dc79e7f19fd311d685bf758ace536ac",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onAction",
    "key": "7d4b06d81bdb29e8dd7710984490b454db30c14a",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "message",
    "key": "80a524956e565142133376c5b666f49bd05cb883",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "focusedMessage",
    "key": "13fa30bfb7e77798e05532aa5d95e689ce8fe300",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onMessage",
    "key": "c90964aa8b922a75dccf63d647084a04f3408c31",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "inboundMessage",
    "key": "563012a9ef6ac8a456a33af731991e9976668d73",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "systemMessage",
    "key": "0fd31dfc163a3f11df082375939821120ee2c0a9",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "borderSystemMessage",
    "key": "647073225e8ff394b0251adf0d6fa602d831d433",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "background",
    "key": "cf7817bd540ba537da50e405e4c7a50ebb5319ea",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onBackground",
    "key": "190e1e048d8f2616d6f057ddccb5509667735077",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "danger",
    "key": "09fc4a7ccfc0b2a63587acada847105171ab02f5",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onDanger",
    "key": "9ad0bac10994e1a43c7cd1ede27898405fc5938b",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "success",
    "key": "a4501a0afde40681948565aa7f1d9cd6ee216de2",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "notify",
    "key": "e79a0e3fd0aa817ce37e350f7cc5c1f60ea07f20",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "disabled",
    "key": "3541b5f8a20efa343d690751c9ae1b70c62429d4",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "icon",
    "key": "6660bd31c0bfb42bd8b044a7dd233293973336fd",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "note",
    "key": "4f9162ff25d0b16dfea4121dd1b1a3ecd006d1c6",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  },
  {
    "name": "onNote",
    "key": "e2510f9b0c5b036e4ef04ff7f0dac1d0f6e7fc3a",
    "theme": "Zendesk (light)",
    "type": "PAINT"
  }
]

var messageCount: number = 0
var log: FrameNode

// This plugin will open a window to prompt the user to enter a message, and
// it will then create a message symbol with that text on screen.

// This file holds the main code for the plugins. It has access to the *document*.
// You can access browser APIs in the <script> tag inside "ui.html" which has a
// full browser environment (see documentation).

// This shows the HTML page in "ui.html".
figma.showUI(__html__)
figma.ui.resize(400, 100)

//Secret bootstrap point setter -- commment out when not in use.
// let launcher = figma.currentPage.selection.find(node => (node.type == "COMPONENT" || node.type == "INSTANCE") && node.parent.name == "Launcher")
// if (launcher){
//   launcher.setRelaunchData({start: ""})
//   figma.closePlugin()
// }

// Calls to "parent.postMessage" from within the HTML page will trigger this
// callback. The callback will be passed the "pluginMessage" property of the
// posted message.
figma.ui.onmessage = async msg => {
  //Look for a "Widget" or a "Messenger" in the current selection
  let widget = figma.currentPage.selection.find(node => node.type === "FRAME" && node.name == "Widget") as FrameNode
  let messenger = figma.currentPage.selection.find(node => node.type === "FRAME" && node.name == "Messenger") as FrameNode
  // Then look for a child 'Log' frame...
  if (widget) {
    log = widget.findOne(node => node.type === "FRAME" && node.name == "Log") as FrameNode;
  } else if (messenger) {
    log = messenger.findOne(node => node.type === "FRAME" && node.name == "Log") as FrameNode;
  }
  // One way of distinguishing between different types of messages sent from
  // your HTML page is to use an object with a "type" property like this...
  switch (msg.type) {
    case 'setup':
      let setupNotification = figma.notify("Setting up widget...", {timeout: Infinity });
      await setUp()
      setupNotification.cancel()
      break
    case 'create-message':
      await sendMessage(msg.messageType, msg.message, msg.direction, msg.isBot)
      break
  }
};

//~~Function to set up a new conversation~~//
async function setUp() {
  if (!log) {
    //Set up styles
    let backgroundStyle = await figma.importStyleByKeyAsync("e94370ef7b3a645e93bd29da94dc67ad6b6ec52e").catch(() => {
      figma.notify("Zcripter requires the 'Zendesk Theme (Default)' library.");
      figma.closePlugin();
    }) as BaseStyle;
    let backgroundEffect = await figma.importStyleByKeyAsync("20b0405ad7024a20ad878b90b3b75bd5bb26443a").catch(() => {
      figma.notify("Zcripter requires the 'Garden' library.");
      figma.closePlugin();
    }) as BaseStyle;

    //Find last widget...
    let otherWidgets = figma.currentPage.findAll(node => node.name == "Widget")

    //Make the container
    let widget = figma.createFrame();
    widget.setRelaunchData({ open: "" });
    widget.name = "Widget";
    // If there are other containers, offset it to the right of the last one.
    if (otherWidgets.length > 0) {
      widget.x = otherWidgets[otherWidgets.length-1].x + 480
      widget.y = otherWidgets[otherWidgets.length-1].y
    } else {
      widget.x = figma.viewport.center.x - 190
      widget.y = figma.viewport.center.y - 390
    }
    widget.resize(380, 780);
    widget.clipsContent = false;
    widget.fills = [];
    widget.layoutMode = "VERTICAL";
    widget.primaryAxisSizingMode = "AUTO";
    widget.counterAxisSizingMode = "AUTO";
    widget.counterAxisAlignItems = "MAX";
    widget.itemSpacing = 8;

    //Make the messenger
    let messenger = figma.createFrame();
    messenger.setRelaunchData({ open: "" });
    messenger.name = "Messenger";
    messenger.resize(380, 700);
    messenger.layoutMode = "VERTICAL";
    messenger.primaryAxisSizingMode = "FIXED";
    messenger.fillStyleId = backgroundStyle.id;
    messenger.effectStyleId = backgroundEffect.id;
    widget.appendChild(messenger);

    //Make the launcher
    let launcher: InstanceNode
    if(figma.command == "start"){
      launcher = figma.currentPage.selection.find(node => node.type == "INSTANCE" && node.name == "Launcher") as InstanceNode
      widget.x = launcher.x - 308
      widget.y = launcher.y - 708
      launcher.swapComponent(await figma.importComponentByKeyAsync("c5f2c7b8417b86629a8e52aa37ebe2c065a2c6de"));
      launcher.parent.appendChild(widget)
    } else {
      launcher = (await figma.importComponentByKeyAsync("c5f2c7b8417b86629a8e52aa37ebe2c065a2c6de")).createInstance()
    }
    launcher.setRelaunchData({})
    widget.appendChild(launcher);

    //Make the header
    let header = (await figma.importComponentByKeyAsync("da85778fa3e3f54485fcedfe1bf2476f851f2f41")).createInstance();
    messenger.appendChild(header);
    let title = header.findChild(node => node.name == "Title") as TextNode;
    await figma.loadFontAsync(title.fontName as FontName).then();
    title.characters = "Zendesk";
    header.layoutAlign = "STRETCH";

    //Make a log frame
    log = figma.createFrame();
    log.name = "Log";
    log.resize(380, 1);
    log.layoutMode = "VERTICAL";
    log.layoutGrow = 1;
    log.layoutAlign = "STRETCH";
    log.overflowDirection = "VERTICAL";
    log.fills = [];
    messenger.appendChild(log);

    //Make the composer
    let composer = (await figma.importComponentByKeyAsync("0cdeaec0c5baf216b6c74d1a939a9c94e025f1df")).createInstance();
    composer.layoutAlign = "STRETCH";
    messenger.appendChild(composer);
    //Ensure the Messenger theme is applied
    applyColor(widget)

    const nodes: SceneNode[] = [];
    nodes.push(widget);
    figma.currentPage.selection = nodes;
    figma.viewport.scrollAndZoomIntoView(nodes);
  }
  //Now that we are sure there is a conversation, check if there is any messages.
  var firstMessage = log.findChild(node => node.name == "0" && node.type === "INSTANCE") as InstanceNode;
  //If there is no first message...
  if (!firstMessage) {
    //Create a first timestamp messsage...
    await figma.importComponentByKeyAsync("663b06bfe927cf5574dc82c60e084da2ee5e99d9").then(timestampComponent => {
      firstMessage = timestampComponent.createInstance();
    });
    firstMessage.name = "0";
    messageCount = 0;
    firstMessage.layoutAlign = "STRETCH";
    let timestamp = firstMessage.findChild(node => node.type == "TEXT" && node.name.includes("Timestamp")) as TextNode
    let d = new Date(Date.now())
    const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    let locDate = months[d.getMonth()] + " " + d.getDate() + ", " + (d.getHours() > 12 ? d.getHours()%12 : d.getHours()) + ":" + ("0" + d.getMinutes()).slice(-2) + " " + (d.getHours()/12 < 1 ? "AM" : "PM")
    setText(timestamp, locDate)
    applyColor(firstMessage)
    log.insertChild(0, firstMessage);
  }
}

//~~Function to send a message~~//
async function sendMessage(messageType: string, messageText: string, directionIsOutbound: boolean, isBot: boolean) {
  //Find the last message in the conversation frame...
  let lastMessageGroup = log.children[log.children.length-1] as InstanceNode
  //...and set the messageCount to the numbered name of this message
  messageCount = parseInt(lastMessageGroup.name)
  let positionInGroup: number

  //If last message type is quick reply, it must be cleaned up.
  if (lastMessageGroup.mainComponent.parent.name == "Quick replies") {
    lastMessageGroup.remove()
    lastMessageGroup = log.children[log.children.length-1] as InstanceNode
    messageCount--
  }

  //If message type is quick reply just add it, as it cannot be grouped.
  if (messageType == "quick reply") {
    let quickRepliesComponent: ComponentNode
    await figma.importComponentSetByKeyAsync("b929d6648712cdcae0f3ce4a4195d2ea70badca2").then( quickRepliesComponentSet => {
      quickRepliesComponent = quickRepliesComponentSet.findChild(component => true) as ComponentNode
    })
    var quickRepliesInstance = quickRepliesComponent?.createInstance()
    quickRepliesInstance.layoutAlign = "STRETCH"
    quickRepliesInstance.name = (++messageCount).toString();
    applyColor(quickRepliesInstance)

    //Insert the new message.
    log.insertChild(messageCount, quickRepliesInstance);

    //Check that the log has not become filled
    if (quickRepliesInstance.y + quickRepliesInstance.height > log.height) {
      log.primaryAxisAlignItems = "MAX"
    }
    return
  }

  //If participant hasn't changed since last message...
  if ((directionIsOutbound && lastMessageGroup.mainComponent.name.startsWith("Direction=Outbound")) ||
  (!directionIsOutbound && lastMessageGroup.mainComponent.name.startsWith("Direction=Inbound"))) {
    positionInGroup = parseInt(lastMessageGroup.variantProperties.Messages) + 1
    //Add to the existing message group
    var nextMessageGroup = lastMessageGroup
    if (positionInGroup < 4) {
      //TODO Investigate making this scalable beyond 3 messages by appending an new message, vs swapping component.
      nextMessageGroup.setProperties({
        Direction: nextMessageGroup.variantProperties.Direction,
        Messages: (positionInGroup).toString()
      })
    } else {
      figma.notify("Conversation Kit currently only supports 3 consecutive messages.")
      return
    }
  } else {
    //Start a new message group...
    positionInGroup = 1
    let messageGroupComponent: ComponentNode
    await figma.importComponentSetByKeyAsync("98e8f2af5cef20537dfbfb1dc294f6fc1f60d466").then( messageGroupComponentSet => {
      messageGroupComponent = directionIsOutbound ? messageGroupComponentSet.findChild(component => component.name === "Direction=Outbound, Messages=1") as ComponentNode : messageGroupComponentSet.findChild(component => component.name === "Direction=Inbound, Messages=1") as ComponentNode
    })
    var nextMessageGroup = messageGroupComponent?.createInstance()
    nextMessageGroup.layoutAlign = "STRETCH"
    nextMessageGroup.name = (++messageCount).toString();

    //Turn off receipts on previous message, if there is one
    let receipt = lastMessageGroup.findOne(node => node.name == "Receipt")
    if (receipt) receipt.visible = false

    //Insert the new message.
    log.insertChild(messageCount, nextMessageGroup);
  }

  //If outbound...
  if (!directionIsOutbound) {
    //...and is bot...
    if (isBot) {
      //Set the author label
      let label = nextMessageGroup.findOne(node => node.type === "TEXT" && node.name == "Label") as TextNode;
      await figma.loadFontAsync(label.fontName as FontName).then(() => {
        label.characters = "Answer Bot";
      });

      //Set the avatar
      let avatar = nextMessageGroup.findOne(node => node.name == "Avatar") as InstanceNode;
      avatar.setProperties({
        Size: "Small",
        Shape: "Square",
        Type: "Image",
        State: "Default"
      })
      let avatarImage = avatar.findChild(node => node.name == "Images") as InstanceNode
      avatarImage.setProperties({ Participant: "Bot" })
    } else {
      //Set the author label, if it is an inbound message
      let label = nextMessageGroup.findOne(node => node.type === "TEXT" && node.name == "Label") as TextNode;
      await figma.loadFontAsync(label.fontName as FontName).then(() => {
        label.characters = "Christina";
      });

      //Set the avatar
      let avatar = nextMessageGroup.findOne(node => node.name == "Avatar") as InstanceNode;
      avatar.setProperties({
        Size: "Small",
        Shape: "Circle",
        Type: "Image",
        State: "Default"
      })
      let avatarImage = avatar.findChild(node => node.name == "Images") as InstanceNode
      avatarImage.setProperties({ Participant: "Agent (Christina)" })
    }
  }

  let message = nextMessageGroup.findOne(node => node.name == "Message " + (positionInGroup)) as InstanceNode
  switch (messageType) {
    case "text":
      //Set the message text
      let text = message.findOne(node => node.type === "TEXT" && node.name == "Text") as TextNode;
      await figma.loadFontAsync(text.fontName as FontName).then(() => {
        text.characters = messageText;
      });
      //Check that the message should not be multi-line
      if( nextMessageGroup.mainComponent.name.startsWith("Direction=Outbound") ? text.width > log.width-92-28 : text.width > log.width-64-60 ){
        message.setProperties({
          Multiline: "True"
        })
      }
      break
    case "image":
      message.setProperties({
        Type: "Image",
        Multiline: "True",
        State: "Sent"
      })
      break
    case "file":
      message.setProperties({
        Type: "File",
        Multiline: "True",
        State: "Sent"
      })
      break
    case "quick reply":
      break
  }

  //Check that the log has not become filled
  if (nextMessageGroup.y + nextMessageGroup.height > log.height) {
    log.primaryAxisAlignItems = "MAX"
  }

  applyColor(nextMessageGroup)
}

//~~~UTILITIES~~~//

//~~Function to safely change text on TextNodes.~~//
async function setText(node: TextNode, text: string) {
  await figma.loadFontAsync(node.fontName as FontName)
  node.characters = text
}

//~~Function to clone fills, etc. so they can be set.~~//
function clone(val) {
  const type = typeof val
  if (val === null) {
    return null
  } else if (type === 'undefined' || type === 'number' ||
             type === 'string' || type === 'boolean') {
    return val
  } else if (type === 'object') {
    if (val instanceof Array) {
      return val.map(x => clone(x))
    } else if (val instanceof Uint8Array) {
      return new Uint8Array(val)
    } else {
      let o = {}
      for (const key in val) {
        o[key] = clone(val[key])
      }
      return o
    }
  }
  throw 'unknown'
}

//~~Function to loop through every node and apply a matching color style if found
//  it will ignore any layer without a fill, background, or stroke style applied
function applyColor(node) {

  //iterate through children if the node has them
  if (node.children) {
      node.children.forEach(child => {
          applyColor(child);
      })
  }

  //handle background fills
  if (node.type === 'COMPONENT'||'INSTANCE'||'FRAME'||'GROUP') {
      if (node.backgroundStyleId) {
          (async function() {
              let style = figma.getStyleById(node.backgroundStyleId) as PaintStyle;
              if (style.key) {
                  let newStyleKey = findMatchInSelectedTheme(style.key);
                  if (newStyleKey) {
                      let newStyle = await figma.importStyleByKeyAsync(newStyleKey) as PaintStyle;
                      if (newStyle) {
                          node.backgroundStyleId = newStyle.id;
                      }
                  }
              }
          })()
      }
  }

  //handle fills + strokes
  if (node.type === 'RECTANGLE'||'POLYGON'||'ELLIPSE'||'STAR'||'TEXT'||'VECTOR'||'BOOLEAN_OPERATION'||'LINE') {
      //fills
      if (node.fillStyleId) {
          (async function() {
              let style = figma.getStyleById(node.fillStyleId) as PaintStyle;
              if (style.key) {
                  let newStyleKey = findMatchInSelectedTheme(style.key);
                  if (newStyleKey) {
                      let newStyle = await figma.importStyleByKeyAsync(newStyleKey) as PaintStyle;
                      if (newStyle) {
                          node.fillStyleId = newStyle.id;
                      }
                  }
              }
          })()
      }
      //strokes
      if (node.strokeStyleId) {
          (async function() {
              let style = figma.getStyleById(node.strokeStyleId) as PaintStyle;
              if (style.key) {
                  let newStyleKey = findMatchInSelectedTheme(style.key);
                  if (newStyleKey) {
                      let newStyle = await figma.importStyleByKeyAsync(newStyleKey) as PaintStyle;
                      if (newStyle) {
                          node.strokeStyleId = newStyle.id;
                      }
                  }
              }
          })()
      }
  }
}
//find matching styles based
function findMatchInSelectedTheme(styleKey) {
  // this gets item in the array which matches the current style applied
  let currentStyle = THEME_ZENDESK.find(style => style.key === styleKey);
  
  // if we find a matching style execute this
  if (currentStyle) {

      //this gets the name of the current style
      //we need the name of the current style so we can search the jsonbin array
      //for matches with the selected theme
      let name = currentStyle.name;
      let matchedStyle = THEME_MESSAGING.find(style => style.name === name);
     
      if (matchedStyle) {
          //if we find a match in the selected theme, we will return the style key
          // so that we can import the style into the doc
          return matchedStyle.key;
      }
  }
}